# -*- coding: utf-8 -*-
"""code.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1D8jThKklpZqMzmxx-tpliy2HBOcjLZxH
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
from sklearn.metrics import mean_squared_error

!pip install kaggle

! mkdir ~/.kaggle

! cp kaggle.json ~/.kaggle/

! chmod 600 ~/.kaggle/kaggle.json

! kaggle datasets download -d aaron7sun/stocknews

!unzip /content/stocknews.zip

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
import pandas_datareader as web
import datetime as dt
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout, LSTM
from tensorflow.keras.callbacks import ModelCheckpoint, EarlyStopping
import matplotlib.dates as dates
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots

data = pd.read_csv('upload_DJIA_table.csv')

data['Date']=pd.to_datetime(data['Date'])
data=data.sort_values('Date')

fig=make_subplots(specs=[[{"secondary_y":False}]])
fig.add_trace(go.Scatter(x=data['Date'],y=data['Open'].rolling(window=7).mean(),name="DJIA"),secondary_y=False,)
fig.update_layout(autosize=False,width=900,height=500,title_text="DJIA")
fig.update_xaxes(title_text="year")
fig.update_yaxes(title_text="prices",secondary_y=False)
fig.show()

n = len(data)

# Calculate the split indices
train_start = (n // 20) * 17
train_end = (n // 20) * 19
test_start = (n // 20) * 19

# Split the data into training and testing sets
train_data = data[train_start:train_end]
test_data = data[test_start:]

# Verify the number of data points in each set
print("Number of data points in the training set:", len(train_data))
print("Number of data points in the testing set:", len(test_data))

fig=make_subplots(specs=[[{"secondary_y":False}]])
fig.add_trace(go.Scatter(x=train_data['Date'],y=train_data['Open'],name="Train"),secondary_y=False,)
fig.add_trace(go.Scatter(x=test_data['Date'],y=test_data['Open'],name="Test"),secondary_y=False,)
fig.update_layout(autosize=False,width=900,height=500,title_text="DJIA")
fig.update_xaxes(title_text="year")
fig.update_yaxes(title_text="prices",secondary_y=False)
fig.show()

test_data[0:3]

print(len(train_data))
print(len(test_data))

scaler = MinMaxScaler(feature_range=(0,1))
scaled_data = scaler.fit_transform(train_data['Open'].values.reshape(-1,1))

prediction_days = 30

x_train = []
y_train = []

for x in range(prediction_days, len(scaled_data)-5):      ######
    x_train.append(scaled_data[x-prediction_days:x, 0])
    y_train.append(scaled_data[x+5, 0])                   ###### predict 5 days after

x_train, y_train = np.array(x_train), np.array(y_train)
x_train = np.reshape(x_train, (x_train.shape[0], x_train.shape[1], 1))

print(x_train.shape)
print(y_train.shape)

def LSTM_model():

    model = Sequential()
    model.add(LSTM(units = 50, return_sequences = True, input_shape = (x_train.shape[1],1)))
    model.add(Dropout(0.2))
    model.add(LSTM(units = 50, return_sequences = True))
    model.add(Dropout(0.2))
    model.add(LSTM(units = 50))
    model.add(Dropout(0.2))
    model.add(Dense(units=1))

    return model

model = LSTM_model()

# Compile the model
model.compile(optimizer='adam', loss='mean_squared_error',metrics = ['accuracy'])

# Train the model with your training data (x_train and y_train)
model.fit(x_train, y_train, epochs=50, batch_size=32)

# Make predictions using the trained model
y_pred = model.predict(x_train)

# Evaluate the model as needed

checkpointer = ModelCheckpoint(filepath = 'weights_best.hdf5', verbose = 1, save_best_only = True)
his=model.fit(x_train,y_train,epochs=20,batch_size=32,callbacks=[checkpointer])

model.summary()

plt.plot(his.history['loss'])
plt.plot(his.history['accuracy'])
plt.title('model loss')
plt.ylabel('loss')
plt.xlabel('epoch')
plt.legend(['loss','accuracy'], loc='upper right')
plt.show()

actual_prices = test_data['Open'].values
total_dataset = pd.concat((train_data['Open'], test_data['Open']), axis=0)

model_inputs = total_dataset[len(total_dataset)-len(test_data)-prediction_days:].values
model_inputs = model_inputs.reshape(-1,1)
model_inputs = scaler.transform(model_inputs)

x_test = []
for x in range(prediction_days,len(model_inputs)):
    x_test.append(model_inputs[x-prediction_days:x,0])

x_test = np.array(x_test)
x_test = np.reshape(x_test,(x_test.shape[0],x_test.shape[1],1))

predicted_prices = model.predict(x_test)
predicted_prices = scaler.inverse_transform(predicted_prices)

x_train = []
y_train = []

for x in range(prediction_days, len(scaled_data) - 5):
    x_train.append(scaled_data[x - prediction_days:x, 0])
    y_train.append(scaled_data[x + 5, 0])  # Predict 5 days after

# Modify the loop to ensure x_train and y_train have the same number of samples
# You can trim the last 5 samples from x_train to match the length of y_train
x_train = x_train[:-5]

x_train, y_train = np.array(x_train), np.array(y_train)
x_train = np.reshape(x_train, (x_train.shape[0], x_train.shape[1], 1))
print(x_train.shape)
print(y_train.shape)



plt.plot(actual_prices, color='red', label=f"Actual price")
plt.plot(predicted_prices, color= 'green', label=f"Predicted 5-days-after price")
plt.title(f"DJIA Stock")
plt.xlabel("Days in test period")
plt.ylabel(f"Price")
plt.legend()
plt.show()

test_data['predict']=predicted_prices
test_data[0:10]

fig=make_subplots(specs=[[{"secondary_y":False}]])
fig.add_trace(go.Scatter(x=train_data['Date'],y=train_data['Open'],name="Train Actual"),secondary_y=False,)
fig.add_trace(go.Scatter(x=test_data['Date'],y=test_data['Open'],name="Test Actual"),secondary_y=False,)
fig.add_trace(go.Scatter(x=test_data['Date'],y=test_data['predict'],name="Predicted 5-days after price"),secondary_y=False,)
fig.update_layout(autosize=False,width=900,height=500,title_text="DJIA")
fig.update_xaxes(title_text="year")
fig.update_yaxes(title_text="prices",secondary_y=False)
fig.show()

real_data = [model_inputs[len(model_inputs)+1-prediction_days:len(model_inputs+1),0]]
real_data = np.array(real_data)
real_data = np.reshape(real_data,(real_data.shape[0],real_data.shape[1],1))
print(real_data.shape)

prediction = model.predict(real_data)
prediction = scaler.inverse_transform(prediction)
print(f"prediction: {prediction[0][0]}")

import pandas as pd
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix

# Load your data and preprocess it as needed
# Assuming you have a DataFrame with 'Date' and 'Open' columns

# Define a threshold for price movement classification (e.g., if Open price increases, it's "Up")
threshold = 0

# Create a new binary column for price movements
data['PriceMovement'] = (data['Open'].diff() > threshold).astype(int)

# Split the data into features (X) and target (y)
X = data[['Open']]
y = data['PriceMovement']

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Create and train a random forest classifier
rf_classifier = RandomForestClassifier(n_estimators=100, random_state=42)
rf_classifier.fit(X_train, y_train)

# Make predictions
y_pred = rf_classifier.predict(X_test)

# Calculate accuracy
accuracy = accuracy_score(y_test, y_pred)
print("Accuracy:", accuracy)

# Display classification report
print(classification_report(y_test, y_pred))

# Create a confusion matrix
confusion = confusion_matrix(y_test, y_pred)
print("Confusion Matrix:")
print(confusion)

import pandas as pd
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import r2_score, mean_squared_error
import matplotlib.pyplot as plt

# Load your time series data
# Assuming you have a DataFrame with 'Date' and 'Open' columns

# Sort the data by date if it's not sorted
data.sort_values(by='Date', inplace=True)

# Split the data into features (X) and target (y)
X = data[['Open']]
y = data['Open']  # Predicting the Open price

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Create and train a Random Forest Regressor
rf_regressor = RandomForestRegressor(n_estimators=100, random_state=42)
rf_regressor.fit(X_train, y_train)

# Make predictions
y_pred = rf_regressor.predict(X_test)

# Calculate R-squared score
r2 = r2_score(y_test, y_pred)
print("R-squared Score:", r2)

# Calculate Mean Squared Error
mse = mean_squared_error(y_test, y_pred)
print("Mean Squared Error:", mse)
combined_data = pd.concat([X_test, pd.Series(y_pred, index=X_test.index)], axis=1)
combined_data.columns = ['Actual', 'Predicted']

from tensorflow.keras.layers import Flatten

def FNN_model():
    model = Sequential()
    model.add(Flatten(input_shape=(x_train.shape[1], 1)))
    model.add(Dense(units=50, activation='relu'))
    model.add(Dense(units=50, activation='relu'))
    model.add(Dense(units=1))
    return model

# Create a new instance of the feedforward neural network model
model_fnn = FNN_model()
model_fnn.summary()
model_fnn.compile(optimizer='adam', loss='mean_squared_error', metrics=['accuracy'])

prediction_days = 30

x_train = []
y_train = []

for x in range(prediction_days, len(scaled_data)-5):      ######
    x_train.append(scaled_data[x-prediction_days:x, 0])
    y_train.append(scaled_data[x+5, 0])                   ###### predict 5 days after

x_train, y_train = np.array(x_train), np.array(y_train)
x_train = np.reshape(x_train, (x_train.shape[0], x_train.shape[1], 1))

# Create the FNN model
model = FNN_model()

# Compile the model
model.compile(optimizer='adam', loss='mean_squared_error', metrics=['accuracy'])

# Train the model with your training data (x_train and y_train)
model.fit(x_train, y_train, epochs=50, batch_size=32)

# Make predictions using the trained model
y_pred = model.predict(x_train)

model_fnn = FNN_model()
model_fnn.summary()
model_fnn.compile(optimizer='adam', loss='mean_squared_error', metrics=['accuracy'])

checkpointer_fnn = ModelCheckpoint(filepath='weights_best_fnn.hdf5', verbose=1, save_best_only=True)
his_fnn = model_fnn.fit(x_train, y_train, epochs=20, batch_size=32, callbacks=[checkpointer_fnn])

predicted_prices_fnn = model_fnn.predict(x_test)
predicted_prices_fnn = scaler.inverse_transform(predicted_prices_fnn)

actual_prices_fnn = test_data['Open'].values
total_dataset_fnn = pd.concat((train_data['Open'], test_data['Open']), axis=0)

model_inputs = total_dataset[len(total_dataset)-len(test_data)-prediction_days:].values
model_inputs = model_inputs.reshape(-1,1)
model_inputs = scaler.transform(model_inputs)

plt.plot(actual_prices_fnn, color='black', label=f"Actual price")
plt.plot(predicted_prices_fnn, color= 'red', label=f"Predicted 5-days-after price")
plt.title(f"DJIA Stock")
plt.xlabel("Days in test period")
plt.ylabel(f"Price")
plt.legend()
plt.show()

test_data['predict']=predicted_prices_fnn
test_data[0:20]

from matplotlib import pyplot as plt
_df_0['Open'].plot(kind='hist', bins=20, title='Open')
plt.gca().spines[['top', 'right',]].set_visible(False)
plt.tight_layout()



import matplotlib.pyplot as plt

# Train the FNN model with your training data (x_train and y_train)
history_fnn = model.fit(x_train, y_train, epochs=50, batch_size=32)

# Create a single graph with both loss and accuracy
plt.figure(figsize=(10, 6))

# Plot loss (MSE)
plt.plot(history_fnn.history['loss'], label='Loss (MSE)')
plt.title('FNN Model Loss ')
plt.ylabel('Loss (MSE)')
plt.xlabel('Epoch')

test_data['predict_fnn'] = predicted_prices_fnn



fig = make_subplots(specs=[[{"secondary_y": False}]])
fig.add_trace(go.Scatter(x=train_data['Date'], y=train_data['Open'], name="Train Actual"), secondary_y=False)
fig.add_trace(go.Scatter(x=test_data['Date'], y=test_data['Open'], name="Test Actual"), secondary_y=False)
fig.add_trace(go.Scatter(x=test_data['Date'], y=test_data['predict'], name="Predicted 5-days after price (LSTM)"), secondary_y=False)
fig.add_trace(go.Scatter(x=test_data['Date'], y=test_data['predict_fnn'], name="Predicted 5-days after price (FNN)"), secondary_y=False)
fig.update_layout(autosize=False, width=900, height=500, title_text="DJIA")
fig.update_xaxes(title_text="year")
fig.update_yaxes(title_text="prices", secondary_y=False)
fig.show()